import { Command } from 'commander';
import chalk from 'chalk';
import simpleGit from 'simple-git';
import fs from 'fs-extra';

const program = new Command();
const git = simpleGit();

program
  .name('git-helper')
  .description('A simple CLI tool to help with common Git commands')
  .version('1.0.0');

program
  .command('init')
  .description('Initialize a new git repository')
  .action(async () => {
    try {
      await git.init();
      console.log(chalk.green('Initialized empty Git repository'));
    } catch (err) {
      console.error(chalk.red('Error initializing repository'), err);
    }
  });

program
  .command('status')
  .description('Check the status of the repository')
  .action(async () => {
    try {
      const status = await git.status();
      console.log(status);
    } catch (err) {
      console.error(chalk.red('Error checking status'), err);
    }
  });

program
  .command('commit')
  .description('Commit changes')
  .argument('<message>', 'Commit message')
  .action(async (message: string) => {
    try {
      await git.add('./*');
      await git.commit(message);
      console.log(chalk.green(`Committed with message: ${message}`));
    } catch (err) {
      console.error(chalk.red('Error committing changes'), err);
    }
  });

program
  .command('push')
  .description('Push changes to the remote repository')
  .argument('[remote]', 'Remote name', 'origin')
  .argument('[branch]', 'Branch name', 'main')
  .action(async (remote: string, branch: string) => {
    try {
      await git.push(remote, branch);
      console.log(chalk.green(`Pushed to ${remote}/${branch}`));
    } catch (err) {
      console.error(chalk.red('Error pushing changes'), err);
    }
  });

program
  .command('branch')
  .description('Create a new branch')
  .argument('<branchName>', 'Name of the new branch')
  .action(async (branchName: string) => {
    try {
      await git.checkoutLocalBranch(branchName);
      console.log(chalk.green(`Switched to new branch '${branchName}'`));
    } catch (err) {
      console.error(chalk.red('Error creating new branch'), err);
    }
  });

program
  .command('merge')
  .description('Merge another branch into the current branch')
  .argument('<branchName>', 'Name of the branch to merge')
  .action(async (branchName: string) => {
    try {
      await git.merge([branchName]);
      console.log(chalk.green(`Merged branch '${branchName}'`));
    } catch (err) {
      console.error(chalk.red('Error merging branch'), err);
    }
  });

program
  .command('init-gitignore')
  .description('Create a .gitignore file with common defaults')
  .action(async () => {
    const gitignoreContent = `
# Node.js
node_modules/
dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Logs
logs
*.log
logs/*.log

# Dependency directories
node_modules/

# Production build
dist/
build/

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov/

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# TypeScript
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# dotenv environment variable files
.env
.env.*.local

# Mac system files
.DS_Store

# Editor directories and files
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# IntelliJ IDEA
.idea/
*.iml

# VS Code
.vscode/

# Optional stylelint cache
.stylelintcache

# Optional Prettier cache
.prettiercache

# Debug files
*.log

# Ignore yarn.lock/pnpm-lock.yaml if using npm
# yarn.lock
# pnpm-lock.yaml
`;

    const gitignorePath = '.gitignore';

    try {
      if (fs.existsSync(gitignorePath)) {
        console.log(chalk.yellow('.gitignore file already exists'));
      } else {
        await fs.writeFile(gitignorePath, gitignoreContent);
        console.log(chalk.green('.gitignore file has been created'));
      }
    } catch (err) {
      console.error(chalk.red('Error creating .gitignore file'), err);
    }
  });
// List all remote repositories
program
  .command('remotes')
  .description('List all remote repositories')
  .action(async () => {
    try {
      const remotes = await git.listRemote(['-v']); // Use listRemote instead of listRemotes
      console.log(remotes);
    } catch (err) {
      console.error(chalk.red('Error listing remotes'), err);
    }
  });

// Add all untracked files
program
  .command('add-all')
  .description('Add all untracked files to the staging area')
  .action(async () => {
    try {
      await git.add('.');
      console.log(chalk.green('Added all untracked files'));
    } catch (err) {
      console.error(chalk.red('Error adding files'), err);
    }
  });

// Show last commit details
program
  .command('log-last')
  .description('Show details of the last commit')
  .action(async () => {
    try {
      const log = await git.log({ n: 1 });
      console.log(log.all[0]);
    } catch (err) {
      console.error(chalk.red('Error getting last commit'), err);
    }
  });

// Checkout an existing branch
program
  .command('checkout')
  .description('Checkout an existing branch')
  .argument('<branchName>', 'Name of the branch to checkout')
  .action(async (branchName: string) => {
    try {
      await git.checkout(branchName);
      console.log(chalk.green(`Switched to branch '${branchName}'`));
    } catch (err) {
      console.error(chalk.red('Error checking out branch'), err);
    }
  });

program.parse(process.argv);
